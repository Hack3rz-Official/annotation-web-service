import File from "./fileClass";


export function useFileFixtures() {
  let java1 = new File("elastic", "elasticsearch", "server/src/main/java/org/elasticsearch/action/index/IndexAction.java");
  let java2 = new File("elastic", "elasticsearch", "server/src/main/java/org/elasticsearch/action/index/IndexRequest.java");
  let java3 = new File("elastic", "elasticsearch", "server/src/main/java/org/elasticsearch/action/index/IndexResponse.java");

  let python1 = new File("pallets", "flask", "src/flask/views.py");
  let python2 = new File("pallets", "flask", "src/flask/typing.py");
  let python3 = new File("pallets", "flask", "src/flask/sessions.py");

  let kotlin1 = new File("JetBrains", "kotless", "model/src/main/kotlin/io/kotless/HTTP.kt")
  let kotlin2 = new File("JetBrains", "kotless", "model/src/main/kotlin/io/kotless/Event.kt")
  let kotlin3 = new File("JetBrains", "kotless", "model/src/main/kotlin/io/kotless/Permission.kt")

  return [java1, java2, java3, python1, python2, python3, kotlin1, kotlin2, kotlin3]
}

const rawCodes = {
  'java': {
    'small': "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License.\n */\npackage org.elasticsearch.benchmark.time;\n\nimport org.elasticsearch.common.time.DateFormatter;\nimport org.elasticsearch.common.time.DateFormatters;\n\nimport java.time.temporal.TemporalAccessor;\nimport java.util.concurrent.TimeUnit;\n\n@Fork(3)\n@SuppressWarnings(\"unused\") // invoked by benchmarking framework\npublic class DateFormatterFromBenchmark {\n\n    private final TemporalAccessor accessor = DateFormatter.forPattern(\"epoch_millis\").parse(\"1234567890\");\n\n    @Benchmark\n    public TemporalAccessor benchmarkFrom() {\n        // benchmark an accessor that does not contain a timezone\n        return DateFormatters.from(accessor);\n    }\n}\n",
    'medium': "/*\n * @notice\n * checkstyle: Checks Java source code for adherence to a set of rules.\n * Copyright (C) 2001-2020 the original author or authors.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\npackage org.elasticsearch.gradle.internal.checkstyle;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FileContents;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n/**\n * This is a copy of Checkstyle's {@link com.puppycrawl.tools.checkstyle.checks.javadoc.MissingJavadocTypeCheck},\n * modified to accept a regex to exclude classes by name. See the original class for full documentation.\n */\n@StatelessCheck\npublic class MissingJavadocTypeCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_JAVADOC_MISSING = \"javadoc.missing\";\n\n    /** Specify the visibility scope where Javadoc comments are checked. */\n    private Scope scope = Scope.PUBLIC;\n\n\n    /**\n     * Specify the list of annotations that allow missed documentation.\n     * Only short names are allowed, e.g. {@code Generated}.\n     */\n    private List<String> skipAnnotations = Collections.singletonList(\"Generated\");\n\n    /**\n     * Setter to specify the visibility scope where Javadoc comments are checked.\n     *\n     * @param scope a scope.\n     */\n    public void setScope(Scope scope) {\n        this.scope = scope;\n    }\n\n    /**\n     * Setter to specify the visibility scope where Javadoc comments are not checked.\n     *\n     * @param excludeScope a scope.\n     */\n    public void setExcludeScope(Scope excludeScope) {\n        this.excludeScope = excludeScope;\n    }\n\n    /**\n     * Setter to specify the list of annotations that allow missed documentation.\n     * Only short names are allowed, e.g. {@code Generated}.\n     *\n     * @param userAnnotations user's value.\n     */\n    public void setSkipAnnotations(String... userAnnotations) {\n        skipAnnotations = Arrays.asList(userAnnotations);\n    }\n\n    /**\n     * Setter to specify pattern for types to ignore.\n     *\n     * @param pattern a pattern.\n     */\n    public final void setIgnorePattern(Pattern pattern) {\n        ignorePattern = pattern;\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getAcceptableTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.RECORD_DEF };\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    // suppress deprecation until https://github.com/checkstyle/checkstyle/issues/11166\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public void visitToken(DetailAST ast) {\n        if (shouldCheck(ast)) {\n            final FileContents contents = getFileContents();\n            final int lineNo = ast.getLineNo();\n            final TextBlock textBlock = contents.getJavadocBefore(lineNo);\n            if (textBlock == null) {\n                log(ast, MSG_JAVADOC_MISSING);\n            }\n        }\n    }\n\n    /**\n     * Whether we should check this node.\n     *\n     * @param ast a given node.\n     * @return whether we should check a given node.\n     */\n    private boolean shouldCheck(final DetailAST ast) {\n        final Scope customScope = ScopeUtil.getScope(ast);\n        final Scope surroundingScope = ScopeUtil.getSurroundingScope(ast);\n\n        final String outerTypeName = ast.findFirstToken(TokenTypes.IDENT).getText();\n\n        return customScope.isIn(scope)\n            && (surroundingScope == null || surroundingScope.isIn(scope))\n            && (excludeScope == null\n                || !customScope.isIn(excludeScope)\n                || surroundingScope != null\n                && !surroundingScope.isIn(excludeScope))\n            && !AnnotationUtil.containsAnnotation(ast, skipAnnotations)\n            && ignorePattern.matcher(outerTypeName).find() == false;\n    }\n\n}\n",
    'large': "/*\n * @notice\n * checkstyle: Checks Java source code for adherence to a set of rules.\n * Copyright (C) 2001-2021 the original author or authors.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\npackage org.elasticsearch.gradle.internal.checkstyle;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\n\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * This is a copy of Checkstyle's {@link com.puppycrawl.tools.checkstyle.checks.coding.HiddenFieldCheck}. See\n * the original class for full documentation.\n */\n@FileStatefulCheck\npublic class HiddenFieldCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"hidden.field\";\n\n    /**\n     * Stack of sets of field names,\n     * one for each class of a set of nested classes.\n     */\n    private FieldFrame frame;\n\n    /** Define the RegExp for names of variables and parameters to ignore. */\n    private Pattern ignoreFormat;\n\n    /**\n     * Allow to ignore the parameter of a property setter method.\n     */\n    private boolean ignoreSetter;\n\n    /**\n     * Allow to expand the definition of a setter method to include methods\n     * that return the class' instance.\n     */\n    private boolean setterCanReturnItsClass;\n\n    /** Control whether to ignore constructor parameters. */\n    private boolean ignoreConstructorParameter;\n\n    /** Control whether to ignore variables in constructor bodies. */\n    private boolean ignoreConstructorBody;\n\n    /** Control whether to ignore parameters of abstract methods. */\n    private boolean ignoreAbstractMethods;\n\n    /** If set, specifies a regex of method names that should be ignored */\n    private String ignoreMethodNames;\n\n    /** If set, specifies a regex of constructor names that should be ignored */\n    private String ignoreConstructorMethods;\n\n    /** Control the minimal amount of lines in method to allow shadowed variables .*/\n    private int minLineCount = -1;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getAcceptableTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.PARAMETER_DEF,\n            TokenTypes.ENUM_CONSTANT_DEF,\n            TokenTypes.PATTERN_VARIABLE_DEF,\n            TokenTypes.LAMBDA,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.RECORD_COMPONENT_DEF, };\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] { TokenTypes.CLASS_DEF, TokenTypes.ENUM_DEF, TokenTypes.ENUM_CONSTANT_DEF, TokenTypes.RECORD_DEF, };\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        frame = new FieldFrame(null, true, null);\n    }\n\n    /**\n     * Process a variable token.\n     * Check whether a local variable or parameter shadows a field.\n     * Store a field for later comparison with local variables and parameters.\n     *\n     * @param ast the variable token.\n     */\n    private void processVariable(DetailAST ast) {\n        if (ScopeUtil.isInInterfaceOrAnnotationBlock(ast) == false\n            && CheckUtil.isReceiverParameter(ast) == false\n            && (ScopeUtil.isLocalVariableDef(ast)\n                || ast.getType() == TokenTypes.PARAMETER_DEF\n                || ast.getType() == TokenTypes.PATTERN_VARIABLE_DEF)) {\n            // local variable or parameter. Does it shadow a field?\n            final DetailAST nameAST = ast.findFirstToken(TokenTypes.IDENT);\n            final String name = nameAST.getText();\n\n            if ((frame.containsStaticField(name) || isInstanceField(ast, name))\n                && isMatchingRegexp(name) == false\n                && isIgnoredParam(ast, name) == false\n                && isIgnoredVariable(ast, name) == false) {\n                log(nameAST, MSG_KEY, name);\n            }\n        }\n    }\n\n    /**\n     * Checks whether method or constructor parameter is ignored.\n     *\n     * @param ast the parameter token.\n     * @param name the parameter name.\n     * @return true if parameter is ignored.\n     */\n    private boolean isIgnoredParam(DetailAST ast, String name) {\n        return isVariableInIgnoredMethod(ast, name)\n            || isIgnoredSetterParam(ast, name)\n            || isIgnoredConstructorParam(ast)\n            || isIgnoredParamOfAbstractMethod(ast);\n    }\n\n    private boolean isIgnoredVariable(DetailAST ast, String name) {\n        return isVariableInConstructorBody(ast, name) ||\n            isVariableInIgnoredConstructor(ast, name);\n    }\n\n    /**\n     * Check for instance field.\n     *\n     * @param ast token\n     * @param name identifier of token\n     * @return true if instance field\n     */\n    private boolean isInstanceField(DetailAST ast, String name) {\n        return isInStatic(ast) == false && frame.containsInstanceField(name);\n    }\n\n    /**\n     * Check name by regExp.\n     *\n     * @param name string value to check\n     * @return true is regexp is matching\n     */\n    private boolean isMatchingRegexp(String name) {\n        return ignoreFormat != null && ignoreFormat.matcher(name).find();\n    }\n\n    /**\n     * Determines whether an AST node is in a static method or static\n     * initializer.\n     *\n     * @param ast the node to check.\n     * @return true if ast is in a static method or a static block;\n     */\n    private static boolean isInStatic(DetailAST ast) {\n        DetailAST parent = ast.getParent();\n        boolean inStatic = false;\n\n        while (parent != null && inStatic == false) {\n            if (parent.getType() == TokenTypes.STATIC_INIT) {\n                inStatic = true;\n            } else if (parent.getType() == TokenTypes.METHOD_DEF && ScopeUtil.isInScope(parent, Scope.ANONINNER) == false\n                || parent.getType() == TokenTypes.VARIABLE_DEF) {\n                    final DetailAST mods = parent.findFirstToken(TokenTypes.MODIFIERS);\n                    inStatic = mods.findFirstToken(TokenTypes.LITERAL_STATIC) != null;\n                    break;\n                } else {\n                    parent = parent.getParent();\n                }\n        }\n        return inStatic;\n    }\n\n    /**\n     * Decides whether to ignore an AST node that is the parameter of a\n     * setter method, where the property setter method for field 'xyz' has\n     * name 'setXyz', one parameter named 'xyz', and return type void\n     * (default behavior) or return type is name of the class in which\n     * such method is declared (allowed only if\n     * {@link #setSetterCanReturnItsClass(boolean)} is called with\n     * value <em>true</em>).\n     *\n     * @param ast the AST to check.\n     * @param name the name of ast.\n     * @return true if ast should be ignored because check property\n     *     ignoreSetter is true and ast is the parameter of a setter method.\n     */\n    private boolean isIgnoredSetterParam(DetailAST ast, String name) {\n        boolean isIgnoredSetterParam = false;\n        if (ignoreSetter && ast.getType() == TokenTypes.PARAMETER_DEF) {\n            final DetailAST parametersAST = ast.getParent();\n            final DetailAST methodAST = parametersAST.getParent();\n            if (parametersAST.getChildCount() == 1 && methodAST.getType() == TokenTypes.METHOD_DEF && isSetterMethod(methodAST, name)) {\n                isIgnoredSetterParam = true;\n            }\n        }\n        return isIgnoredSetterParam;\n    }\n\n    /**\n     * Determine if a specific method identified by methodAST and a single\n     * variable name aName is a setter. This recognition partially depends\n     * on setterCanReturnItsClass property.\n     *\n     * @param aMethodAST AST corresponding to a method call\n     * @param aName name of single parameter of this method.\n     * @return true of false indicating of method is a setter or not.\n     */\n    private boolean isSetterMethod(DetailAST aMethodAST, String aName) {\n        final String methodName = aMethodAST.findFirstToken(TokenTypes.IDENT).getText();\n        boolean isSetterMethod = false;\n\n        // ES also allows setters with the same name as a property, and builder-style settings that start with \"with\".\n        final List<String> possibleSetterNames = List.of(\n            \"set\" + capitalize(aName, true),\n            \"set\" + capitalize(aName, false),\n            \"with\" + capitalize(aName, true),\n            \"with\" + capitalize(aName, false),\n            aName\n        );\n\n        if (possibleSetterNames.contains(methodName)) {\n            // method name did match set${Name}(${anyType} ${aName})\n            // where ${Name} is capitalized version of ${aName}\n            // therefore this method is potentially a setter\n            final DetailAST typeAST = aMethodAST.findFirstToken(TokenTypes.TYPE);\n            final String returnType = typeAST.getFirstChild().getText();\n\n            // The method is named `setFoo`, `withFoo`, or just `foo` and returns void\n            final boolean returnsVoid = typeAST.findFirstToken(TokenTypes.LITERAL_VOID) != null;\n\n            // Or the method is named as above, and returns the class type or a builder type.\n            // It ought to be possible to see if we're in a `${returnType}.Builder`, but for some reason the parse\n            // tree has `returnType` as `.` when the current class is `Builder` so instead assume that a class called `Builder` is OK.\n            final boolean returnsSelf = setterCanReturnItsClass && frame.isEmbeddedIn(returnType);\n\n            final boolean returnsBuilder = setterCanReturnItsClass\n                && (frame.isEmbeddedIn(returnType + \"Builder\") || (frame.isEmbeddedIn(\"Builder\")));\n\n            if (returnsVoid || returnsSelf || returnsBuilder) {\n                isSetterMethod = true;\n            }\n        }\n\n        return isSetterMethod;\n    }\n\n    /**\n     * Decides whether to ignore an AST node that is witin a method that ought to be ignored.\n     * This is either because:\n     *\n     * <ul>\n     *   <li>The method name matches the {@link #ignoreMethodNames} regex, if set.</li>\n     *   <li>The method's line length is less that or equal to the {@link #minLineCount}</li>\n     * </ul>\n     *\n     * @param ast the AST to check\n     * @return true is the ast node should be ignored\n     */\n    private boolean isVariableInIgnoredMethod(DetailAST ast, String name) {\n        boolean result = false;\n        if (ignoreMethodNames != null && (ast.getType() == TokenTypes.PARAMETER_DEF || ast.getType() == TokenTypes.VARIABLE_DEF)) {\n            DetailAST method = ast.getParent();\n            while (method != null && method.getType() != TokenTypes.METHOD_DEF) {\n                method = method.getParent();\n            }\n            if (method != null && method.getType() == TokenTypes.METHOD_DEF) {\n                final String methodName = method.findFirstToken(TokenTypes.IDENT).getText();\n                result = methodName.matches(ignoreMethodNames) || getMethodsNumberOfLine(method) <= this.minLineCount;\n            }\n        }\n        return result;\n    }\n\n    private boolean isVariableInConstructorBody(DetailAST ast, String name) {\n        boolean result = false;\n\n        if (ignoreConstructorBody && ast.getType() == TokenTypes.VARIABLE_DEF) {\n            DetailAST method = ast.getParent();\n            while (method != null && method.getType() != TokenTypes.CTOR_DEF) {\n                method = method.getParent();\n            }\n            result = method != null && method.getType() == TokenTypes.CTOR_DEF;\n        }\n\n        return result;\n    }\n\n\n\n    /**\n     * Setter to define the RegExp for names of variables and parameters to ignore.\n     *\n     * @param pattern a pattern.\n     */\n    public void setIgnoreFormat(Pattern pattern) {\n        ignoreFormat = pattern;\n    }\n\n    /**\n     * Setter to allow to ignore the parameter of a property setter method.\n     *\n     * @param ignoreSetter decide whether to ignore the parameter of\n     *     a property setter method.\n     */\n    public void setIgnoreSetter(boolean ignoreSetter) {\n        this.ignoreSetter = ignoreSetter;\n    }\n\n    /**\n     * Setter to allow to expand the definition of a setter method to include methods\n     * that return the class' instance.\n     *\n     * @param aSetterCanReturnItsClass if true then setter can return\n     *        either void or class in which it is declared. If false then\n     *        in order to be recognized as setter method (otherwise\n     *        already recognized as a setter) must return void.  Later is\n     *        the default behavior.\n     */\n    public void setSetterCanReturnItsClass(boolean aSetterCanReturnItsClass) {\n        setterCanReturnItsClass = aSetterCanReturnItsClass;\n    }\n\n    /**\n     * Setter to control whether to ignore constructor parameters.\n     *\n     * @param ignoreConstructorParameter decide whether to ignore\n     *     constructor parameters.\n     */\n    public void setIgnoreConstructorParameter(boolean ignoreConstructorParameter) {\n        this.ignoreConstructorParameter = ignoreConstructorParameter;\n    }\n\n    /**\n     * Setter to control whether to ignore parameters of abstract methods.\n     *\n     * @param ignoreAbstractMethods decide whether to ignore\n     *     parameters of abstract methods.\n     */\n    public void setIgnoreAbstractMethods(boolean ignoreAbstractMethods) {\n        this.ignoreAbstractMethods = ignoreAbstractMethods;\n    }\n\n    public void setIgnoreMethodNames(String ignoreMethodNames) {\n        this.ignoreMethodNames = ignoreMethodNames;\n    }\n\n\n    /**\n     * Holds the names of static and instance fields of a type.\n     */\n    private static class FieldFrame {\n\n        /** Name of the frame, such name of the class or enum declaration. */\n        private final String frameName;\n\n        /** Is this a static inner type. */\n        private final boolean staticType;\n\n        /** Parent frame. */\n        private final FieldFrame parent;\n\n        /** Set of instance field names. */\n        private final Set<String> instanceFields = new HashSet<>();\n\n        /** Set of static field names. */\n        private final Set<String> staticFields = new HashSet<>();\n\n        /**\n         * Creates new frame.\n         *\n         * @param parent parent frame.\n         * @param staticType is this a static inner type (class or enum).\n         * @param frameName name associated with the frame, which can be a\n         */\n        /* package */ FieldFrame(FieldFrame parent, boolean staticType, String frameName) {\n            this.parent = parent;\n            this.staticType = staticType;\n            this.frameName = frameName;\n        }\n\n        /**\n         * Adds an instance field to this FieldFrame.\n         *\n         * @param field  the name of the instance field.\n         */\n        public void addInstanceField(String field) {\n            instanceFields.add(field);\n        }\n\n        /**\n         * Adds a static field to this FieldFrame.\n         *\n         * @param field  the name of the instance field.\n         */\n        public void addStaticField(String field) {\n            staticFields.add(field);\n        }\n\n        /**\n         * Determines whether this FieldFrame contains an instance field.\n         *\n         * @param field the field to check.\n         * @return true if this FieldFrame contains instance field field.\n         */\n        public boolean containsInstanceField(String field) {\n            return instanceFields.contains(field) || parent != null && staticType == false && parent.containsInstanceField(field);\n        }\n\n        /**\n         * Determines whether this FieldFrame contains a static field.\n         *\n         * @param field the field to check.\n         * @return true if this FieldFrame contains static field field.\n         */\n        public boolean containsStaticField(String field) {\n            return staticFields.contains(field) || parent != null && parent.containsStaticField(field);\n        }\n\n        /**\n         * Getter for parent frame.\n         *\n         * @return parent frame.\n         */\n        public FieldFrame getParent() {\n            return parent;\n        }\n\n        /**\n         * Check if current frame is embedded in class or enum with\n         * specific name.\n         *\n         * @param classOrEnumName name of class or enum that we are looking\n         *     for in the chain of field frames.\n         *\n         * @return true if current frame is embedded in class or enum\n         *     with name classOrNameName\n         */\n        private boolean isEmbeddedIn(String classOrEnumName) {\n            FieldFrame currentFrame = this;\n            boolean isEmbeddedIn = false;\n            while (currentFrame != null) {\n                if (Objects.equals(currentFrame.frameName, classOrEnumName)) {\n                    isEmbeddedIn = true;\n                    break;\n                }\n                currentFrame = currentFrame.parent;\n            }\n            return isEmbeddedIn;\n        }\n\n    }\n\n    private static int getMethodsNumberOfLine(DetailAST methodDef) {\n        final int numberOfLines;\n        final DetailAST lcurly = methodDef.getLastChild();\n        final DetailAST rcurly = lcurly.getLastChild();\n\n        if (lcurly.getFirstChild() == rcurly) {\n            numberOfLines = 1;\n        }\n        else {\n            numberOfLines = rcurly.getLineNo() - lcurly.getLineNo() - 1;\n        }\n        return numberOfLines;\n    }\n\n}\n"
  },
  'python3': {
    'small': "import pytest\nfrom flask import template_rendered\n\n@pytest.mark.parametrize(\n    (\"path\", \"template_name\"),\n    (\n        (\"/\", \"plain.html\"),\n        (\"/plain\", \"plain.html\"),\n        (\"/fetch\", \"fetch.html\"),\n    ),\n)\ndef test_index(app, client, path, template_name):\n    def check(sender, template, context):\n        assert template.name == template_name\n\n    with template_rendered.connected_to(check, app):\n        client.get(path)\n\n@pytest.mark.parametrize(\n    (\"a\", \"b\", \"result\"), ((2, 3, 5), (2.5, 3, 5.5), (2, None, 2), (2, \"b\", 2))\n)\ndef test_add(client, a, b, result):\n    response = client.post(\"/add\", data={\"a\": a, \"b\": b})\n    assert response.get_json()[\"result\"] == result\n",
    'medium': "import os\nimport typing as t\nfrom warnings import warn\n\nfrom .app import Flask\nfrom .blueprints import Blueprint\nfrom .globals import _request_ctx_stack\n\nclass DebugFilesKeyError(KeyError, AssertionError):\n    \"\"\"Raised from request.files during debugging.  The idea is that it can\n    provide a better error message than just a generic KeyError/BadRequest.\n    \"\"\"\n\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = [\n            f\"You tried to access the file {key!r} in the request.files\"\n            \" dictionary but it does not exist. The mimetype for the\"\n            f\" request is {request.mimetype!r} instead of\"\n            \" 'multipart/form-data' which means that no file contents\"\n            \" were transmitted. To fix this error you should provide\"\n            ' enctype=\"multipart/form-data\" in your form.'\n        ]\n        if form_matches:\n            names = \", \".join(repr(x) for x in form_matches)\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                f\"This was submitted: {names}\"\n            )\n        self.msg = \"\".join(buf)\n\n    def __str__(self):\n        return self.msg\n\n\nclass FormDataRoutingRedirect(AssertionError):\n    \"\"\"This exception is raised in debug mode if a routing redirect\n    would cause the browser to drop the method or body. This happens\n    when method is not GET, HEAD or OPTIONS and the status code is not\n    307 or 308.\n    \"\"\"\n\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = [\n            f\"A request was sent to '{request.url}', but routing issued\"\n            f\" a redirect to the canonical URL '{exc.new_url}'.\"\n        ]\n\n        if f\"{request.base_url}/\" == exc.new_url.partition(\"?\")[0]:\n            buf.append(\n                \" The URL was defined with a trailing slash. Flask\"\n                \" will redirect to the URL with a trailing slash if it\"\n                \" was accessed without one.\"\n            )\n\n        buf.append(\n            \" Send requests to the canonical URL, or use 307 or 308 for\"\n            \" routing redirects. Otherwise, browsers will drop form\"\n            \" data.\\n\\n\"\n            \"This exception is only raised in debug mode.\"\n        )\n        super().__init__(\"\".join(buf))\n\n\ndef attach_enctype_error_multidict(request):\n    \"\"\"Patch ``request.files.__getitem__`` to raise a descriptive error\n    about ``enctype=multipart/form-data``.\n\n    :param request: The request to patch.\n    :meta private:\n    \"\"\"\n    oldcls = request.files.__class__\n\n    class newcls(oldcls):\n        def __getitem__(self, key):\n            try:\n                return super().__getitem__(key)\n            except KeyError as e:\n                if key not in request.form:\n                    raise\n\n                raise DebugFilesKeyError(request, key).with_traceback(\n                    e.__traceback__\n                ) from None\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls\n\n\ndef explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = [f\"Locating template {template!r}:\"]\n    total_found = 0\n    blueprint = None\n    reqctx = _request_ctx_stack.top\n    if reqctx is not None and reqctx.request.blueprint is not None:\n        blueprint = reqctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, Flask):\n            src_info = f\"application {srcobj.import_name!r}\"\n        elif isinstance(srcobj, Blueprint):\n            src_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f\"{idx + 1:5}: trying loader of {src_info}\")\n\n        for line in _dump_loader_info(loader):\n            info.append(f\"       {line}\")\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = f\"found ({triple[1] or '<string>'!r})\"\n            total_found += 1\n        info.append(f\"       -> {detail}\")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that belongs\"\n            f\" to the blueprint {blueprint!r}.\"\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n\n    app.logger.info(\"\\n\".join(info))\n\n\ndef explain_ignored_app_run() -> None:\n    if os.environ.get(\"WERKZEUG_RUN_MAIN\") != \"true\":\n        warn(\n            Warning(\n                \"Silently ignoring app.run() because the application is\"\n                \" run from the flask command line executable. Consider\"\n                ' putting app.run() behind an if __name__ == \"__main__\"'\n                \" guard to silence this warning.\"\n            ),\n            stacklevel=3,\n        )",
    'large': "import sys\nimport typing as t\nfrom functools import update_wrapper\nfrom types import TracebackType\n\nfrom werkzeug.exceptions import HTTPException\n\nfrom .globals import _app_ctx_stack\nfrom .globals import _request_ctx_stack\nfrom .signals import appcontext_popped\nfrom .signals import appcontext_pushed\nfrom .typing import AfterRequestCallable\n\nif t.TYPE_CHECKING:\n    from .app import Flask\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n\n# a singleton sentinel value for parameter defaults\n_sentinel = object()\n\n\nclass _AppCtxGlobals:\n    \"\"\"A plain object. Used as a namespace for storing data during an\n    application context.\n\n    Creating an app context automatically creates this object, which is\n    made available as the :data:`g` proxy.\n\n    .. describe:: 'key' in g\n\n        Check whether an attribute is present.\n\n        .. versionadded:: 0.10\n\n    .. describe:: iter(g)\n\n        Return an iterator over the attribute names.\n\n        .. versionadded:: 0.10\n    \"\"\"\n\n    # Define attr methods to let mypy know this is a namespace object\n    # that has arbitrary attributes.\n\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def get(self, name: str, default: t.Optional[t.Any] = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__.get(name, default)\n\n    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:\n        \"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n        :param name: Name of attribute to pop.\n        :param default: Value to return if the attribute is not present,\n            instead of raising a ``KeyError``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)\n\n    def setdefault(self, name: str, default: t.Any = None) -> t.Any:\n        \"\"\"Get the value of an attribute if it is present, otherwise\n        set and return a default value. Like :meth:`dict.setdefault`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to set and return if the attribute is not\n            present.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.__dict__.setdefault(name, default)\n\n    def __contains__(self, item: str) -> bool:\n        return item in self.__dict__\n\n    def __iter__(self) -> t.Iterator[str]:\n        return iter(self.__dict__)\n\n    def __repr__(self) -> str:\n        top = _app_ctx_stack.top\n        if top is not None:\n            return f\"<flask.g of {top.app.name!r}>\"\n        return object.__repr__(self)\n\n\ndef after_this_request(f: AfterRequestCallable) -> AfterRequestCallable:\n    \"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n    some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    top = _request_ctx_stack.top\n\n    if top is None:\n        raise RuntimeError(\n            \"This decorator can only be used when a request context is\"\n            \" active, such as within a view function.\"\n        )\n\n    top._after_request_functions.append(f)\n    return f\n\n\ndef copy_current_request_context(f: t.Callable) -> t.Callable:\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.  The current session is also\n    included in the copied request context.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    top = _request_ctx_stack.top\n\n    if top is None:\n        raise RuntimeError(\n            \"This decorator can only be used when a request context is\"\n            \" active, such as within a view function.\"\n        )\n\n    reqctx = top.copy()\n\n    def wrapper(*args, **kwargs):\n        with reqctx:\n            return reqctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)\n\n\ndef has_request_context() -> bool:\n    \"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information if the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _request_ctx_stack.top is not None\n\n\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _app_ctx_stack.top is not None\n\n\nclass AppContext:\n    \"\"\"The application context binds an application object implicitly\n    to the current thread or greenlet, similar to how the\n    :class:`RequestContext` binds request information.  The application\n    context is also implicitly created if a request context is created\n    but the application is not on top of the individual application\n    context.\n    \"\"\"\n\n    def __init__(self, app: \"Flask\") -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g = app.app_ctx_globals_class()\n\n        # Like request context, app contexts can be pushed multiple times\n        # but there a basic \"refcount\" is enough to track them.\n        self._refcnt = 0\n\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._refcnt += 1\n        _app_ctx_stack.push(self)\n        appcontext_pushed.send(self.app)\n\n    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            self._refcnt -= 1\n            if self._refcnt <= 0:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            rv = _app_ctx_stack.pop()\n        assert rv is self, f\"Popped wrong app context.  ({rv!r} instead of {self!r})\"\n        appcontext_popped.send(self.app)\n\n    def __enter__(self) -> \"AppContext\":\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: t.Optional[type],\n        exc_value: t.Optional[BaseException],\n        tb: t.Optional[TracebackType],\n    ) -> None:\n        self.pop(exc_value)\n\n\nclass RequestContext:\n    \"\"\"The request context contains all request relevant information.  It is\n    created at the beginning of the request and pushed to the\n    `_request_ctx_stack` and removed at the end of it.  It will create the\n    URL adapter and request object for the WSGI environment provided.\n\n    Do not attempt to use this class directly, instead use\n    :meth:`~flask.Flask.test_request_context` and\n    :meth:`~flask.Flask.request_context` to create this object.\n\n    You might find this helpful for unittests where you need the\n    information from the context local around for a little longer.  Make\n    sure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in\n    that situation, otherwise your unittests will leak memory.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: \"Flask\",\n        environ: dict,\n        request: t.Optional[\"Request\"] = None,\n        session: t.Optional[\"SessionMixin\"] = None,\n    ) -> None:\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n        self.request = request\n        self.url_adapter = None\n        try:\n            self.url_adapter = app.create_url_adapter(self.request)\n        except HTTPException as e:\n            self.request.routing_exception = e\n        self.flashes = None\n        self.session = session\n\n        # Request contexts can be pushed multiple times and interleaved with\n        # other request contexts.  Now only if the last level is popped we\n        # get rid of them.  Additionally if an application context is missing\n        # one is created implicitly so for each level we add this information\n        self._implicit_app_ctx_stack: t.List[t.Optional[\"AppContext\"]] = []\n\n        # indicator if the context was preserved.  Next time another context\n        # is pushed the preserved context is popped.\n        self.preserved = False\n\n        # remembers the exception for pop if there is one in case the context\n        # preservation kicks in.\n        self._preserved_exc = None\n\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions: t.List[AfterRequestCallable] = []\n\n    @property\n    def g(self) -> _AppCtxGlobals:\n        import warnings\n\n        warnings.warn(\n            \"Accessing 'g' on the request context is deprecated and\"\n            \" will be removed in Flask 2.2. Access `g` directly or from\"\n            \"the application context instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return _app_ctx_stack.top.g\n\n    @g.setter\n    def g(self, value: _AppCtxGlobals) -> None:\n        import warnings\n\n        warnings.warn(\n            \"Setting 'g' on the request context is deprecated and\"\n            \" will be removed in Flask 2.2. Set it on the application\"\n            \" context instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        _app_ctx_stack.top.g = value\n\n    def copy(self) -> \"RequestContext\":\n        \"\"\"Creates a copy of this request context with the same request object.\n        This can be used to move a request context to a different greenlet.\n        Because the actual request object is the same this cannot be used to\n        move a request context to a different thread unless access to the\n        request object is locked.\n\n        .. versionadded:: 0.10\n\n        .. versionchanged:: 1.1\n           The current session object is used instead of reloading the original\n           data. This prevents `flask.session` pointing to an out-of-date object.\n        \"\"\"\n        return self.__class__(\n            self.app,\n            environ=self.request.environ,\n            request=self.request,\n            session=self.session,\n        )\n\n    def match_request(self) -> None:\n        \"\"\"Can be overridden by a subclass to hook into the matching\n        of the request.\n        \"\"\"\n        try:\n            result = self.url_adapter.match(return_rule=True)  # type: ignore\n            self.request.url_rule, self.request.view_args = result  # type: ignore\n        except HTTPException as e:\n            self.request.routing_exception = e\n\n    def push(self) -> None:\n        \"\"\"Binds the request context to the current context.\"\"\"\n        # If an exception occurs in debug mode or if context preservation is\n        # activated under exception situations exactly one context stays\n        # on the stack.  The rationale is that you want to access that\n        # information under debug situations.  However if someone forgets to\n        # pop that context again we want to make sure that on the next push\n        # it's invalidated, otherwise we run at risk that something leaks\n        # memory.  This is usually only a problem in test suite since this\n        # functionality is not active in production environments.\n        top = _request_ctx_stack.top\n        if top is not None and top.preserved:\n            top.pop(top._preserved_exc)\n\n        # Before we push the request context we have to ensure that there\n        # is an application context.\n        app_ctx = _app_ctx_stack.top\n        if app_ctx is None or app_ctx.app != self.app:\n            app_ctx = self.app.app_context()\n            app_ctx.push()\n            self._implicit_app_ctx_stack.append(app_ctx)\n        else:\n            self._implicit_app_ctx_stack.append(None)\n\n        _request_ctx_stack.push(self)\n\n        # Open the session at the moment that the request context is available.\n        # This allows a custom open_session method to use the request context.\n        # Only open a new session if this is the first time the request was\n        # pushed, otherwise stream_with_context loses the session.\n        if self.session is None:\n            session_interface = self.app.session_interface\n            self.session = session_interface.open_session(self.app, self.request)\n\n            if self.session is None:\n                self.session = session_interface.make_null_session(self.app)\n\n        # Match the request URL after loading the session, so that the\n        # session is available in custom URL converters.\n        if self.url_adapter is not None:\n            self.match_request()\n\n    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the request context and unbinds it by doing that.  This will\n        also trigger the execution of functions registered by the\n        :meth:`~flask.Flask.teardown_request` decorator.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.\n        \"\"\"\n        app_ctx = self._implicit_app_ctx_stack.pop()\n        clear_request = False\n\n        try:\n            if not self._implicit_app_ctx_stack:\n                self.preserved = False\n                self._preserved_exc = None\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_request(exc)\n\n                request_close = getattr(self.request, \"close\", None)\n                if request_close is not None:\n                    request_close()\n                clear_request = True\n        finally:\n            rv = _request_ctx_stack.pop()\n\n            # get rid of circular dependencies at the end of the request\n            # so that we don't require the GC to be active.\n            if clear_request:\n                rv.request.environ[\"werkzeug.request\"] = None\n\n            # Get rid of the app as well if necessary.\n            if app_ctx is not None:\n                app_ctx.pop(exc)\n\n            assert (\n                rv is self\n            ), f\"Popped wrong request context. ({rv!r} instead of {self!r})\"\n\n    def auto_pop(self, exc: t.Optional[BaseException]) -> None:\n        if self.request.environ.get(\"flask._preserve_context\") or (\n            exc is not None and self.app.preserve_context_on_exception\n        ):\n            self.preserved = True\n            self._preserved_exc = exc  # type: ignore\n        else:\n            self.pop(exc)\n\n    def __enter__(self) -> \"RequestContext\":\n        self.push()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: t.Optional[type],\n        exc_value: t.Optional[BaseException],\n        tb: t.Optional[TracebackType],\n    ) -> None:\n        # do not pop the request stack if we are in debug mode and an\n        # exception happened.  This will allow the debugger to still\n        # access the request object in the interactive shell.  Furthermore\n        # the context can be force kept alive for the test client.\n        # See flask.testing for how this works.\n        self.auto_pop(exc_value)\n\n    def __repr__(self) -> str:\n        return (\n            f\"<{type(self).__name__} {self.request.url!r}\"\n            f\" [{self.request.method}] of {self.app.name}>\"\n        )\n"
  },
  'kotlin': {
    'small': "package io.kotless.dsl.model\n\nimport io.kotless.MimeType\nimport kotlinx.serialization.Serializable\nimport java.util.*\n\n\n/**\n * HTTP's response ApiGateway representation\n *\n * @param statusCode status code to return\n * @param headers headers to pass to client\n * @param body payload of response\n */\n@Serializable\ndata class HttpResponse(val statusCode: Int, val headers: HashMap<String, String> = HashMap(), val body: String?, val isBase64Encoded: Boolean) {\n\n    constructor(statusCode: Int, mime: MimeType, body: String? = null) : this(statusCode, hashMapOf(\"Content-Type\" to mime.mimeText), body, false)\n    constructor(statusCode: Int, mime: MimeType, body: ByteArray)\n        : this(statusCode, hashMapOf(\"Content-Type\" to mime.mimeText), Base64.getEncoder().encodeToString(body), true) {\n        require(mime.isBinary) { \"Base64 encoded response can be used only for binary types\" }\n    }\n}\n\n",  
    'medium': "package io.kotless.examples.site.pages\n\nimport io.kotless.examples.site.bootstrap.doc\nimport io.kotless.examples.site.bootstrap.kotlin\nimport kotlinx.html.*\n\nobject IntroductionPages {\n\n    fun introduction() = doc {\n        h1 {\n            +\"Getting started\"\n        }\n        p {\n            +\"In this short tutorial we will overview all steps of Kotless-based application creation. \\n\"\n        }\n\n\n        h3 {\n            +\"Preliminaries\"\n        }\n        p {\n            +\"To use Kotless in you project you will need:\"\n        }\n        ul {\n            li {\n                +\"Route53 DNS zone to create DNS name for application\"\n            }\n            li {\n                +\"S3 bucket to store kotless-related artifacts\"\n            }\n            li {\n                +\"ACM certificate for DNS name at US-EAST-1\"\n            }\n        }\n\n        h3 {\n            +\"Setting up Gradle project\"\n        }\n        p {\n            +\"\"\"First of all, you will need to set up Gradle for your project. Kotless uses Gradle tasks\n                to prepare deployment environment, generate deployment code, prepare lambda JAR and deploy\n                it to cloud provider.\"\"\"\n        }\n\n        p {\n            +\"You will need to apply a plugin to project at build.gradle.kts:\"\n        }\n\n        p {\n            +\"\"\"To use Kotless DSL in project you will need to set up a maven repository with DSL and\n                        add needed dependency:\"\"\"\n        }\n\n        kotlin(\n            \"\"\"\n                repositories {\n                    jcenter()\n                }\n                dependencies {\n                    implementation(\"io.kotless\", \"kotless-lang\", \"0.1.1\")\n                }\"\"\"\n        )\n\n        p {\n            +\"Now you will need to set up Kotless. Here is a simple configuration with comments:\"\n        }\n\n        kotlin(\n            \"\"\"\n                kotless {\n                    config {\n                        //bucket that kotless will use to store its artifacts\n                        bucket = \"kotless-example-bucket\"\n                        //prefix that will be added to all resources created in AWS\n                        prefix = \"dev\"\n\n                        //directory against which @StaticGet annotated files are resolved\n                        workDirectory = file(\"src/main/static\")\n\n                        terraform {\n                            profile = \"example-profile\"\n                            region = \"us-east-1\"\n                        }\n                    }\n\n                    //webapp for this gradle project\n                    webapp {\n                        //configuration of lambda created\n                        lambda {\n                            memoryMb = 1024\n                            timeoutSec = 120\n                        }\n\n                        //packages in which kotless should search for code\n                        packages = setOf(\"org.example.kotless\")\n                        //route53 alias for deployed application\n                        route53 = Route53(\"kotless\", \"example.org\")\n                    }\n                }\"\"\"\n        )\n\n        h3 {\n            +\"Writing dynamic route\"\n        }\n\n        p {\n            +\"\"\"In Kotless terminology \"dynamic route\" is an HTTP route processed by a lambda.\n                On the contrary, \"static route\" is an HTTP route mapped to S3 object.\"\"\"\n        }\n\n        p {\n            +\"\"\"Creating of dynamic route is relatively simple. This code snippet will\n                create route at HTTP path \"/\" which will print \"Hello world!\"\"\"\"\n        }\n\n        kotlin(\n            \"\"\"\n                @Get(\"/\")\n                fun root(): String {\n                    return \"Hello world!\"\n                }\"\"\"\n        )\n\n\n        p {\n            +\"\"\"Note, that dynamic route function may have parameters. Parameters will be taken from\n                URL and body(if presented) and deserialized to parameters of function. Moreover, the\n                result of function also will be serialized to HTTP response automatically. In case you need\n                full control on the HTTP response you may return `HttpResponse` object,\n                which will be passed to ApiGateway without any changes.\"\"\"\n        }\n\n        h3 {\n            +\"Adding statics to your application\"\n        }\n\n        p {\n            +\"\"\"Most of the real world applications contain static resources, e.g. CSS and JS files. It is a very wasteful\n                spending of resources to serve static resources with lambdas. So, Kotless proposes solution --\n                static resources mapped directly to S3.\"\"\"\n        }\n\n\n        p {\n            +\"This code snippet will create route at HTTP path `/file.css` with file `example.css`\"\n        }\n\n    }\n}\n",
    'large': "package io.kotless.examples.site.pages\n\nimport io.kotless.examples.site.bootstrap.doc\nimport io.kotless.examples.site.bootstrap.kotlin\nimport kotlinx.html.*\n\nobject DSLPages {\n    fun overview() = doc {\n        h1 {\n            +\"Overview\"\n        }\n\n        p {\n            +\"\"\"Kotless DSL is a set of interfaces to various subsystems helping you\n                to build your serverless application.\"\"\"\n        }\n\n        p {\n            +\"It includes:\"\n        }\n\n        ul {\n            li {\n                +\"HTTP API - DSL to create HTTP-based applications\"\n            }\n            li {\n                +\"Lifecycle API - interfaces to control and extend lambda lifecycle\"\n            }\n            li {\n                +\"Permissions API - annotations to grant permissions to resources in a declarative way\"\n            }\n        }\n\n        p {\n            +\"\"\"Kotless DSL is used during preprocessing and in a runtime. For example, HTTP API\n                contains `@Get` annotation, which will be used in a preprocessing time to generate HTTP routes\n                deployment description and in a runtime to dispatch requests to it.\"\"\"\n        }\n\n        p {\n            +\"\"\"Number of provided APIs will continue to grow with growth of Kotless itself. Furthermore, each\n                API may grow to support more use cases.\"\"\"\n        }\n    }\n\n    fun lifecycle() = doc {\n        h1 {\n            +\"Lifecycle API\"\n        }\n\n        p {\n            +\"\"\"Kotless DSL provides an interface to control and extend lambda lifecycle.\n                It includes extension points for warming and initialization sequences.\"\"\"\n        }\n\n        h3 {\n            +\"Warming\"\n        }\n\n        p {\n            +\"\"\"Kotless lambdas can be autowarmed. It means, that some scheduler will\n                periodically (by default, each 5 minutes) call lambda to be sure, that\n                it will not be displaced from hot pool of cloud provider.\"\"\"\n        }\n\n        p {\n            +\"\"\"Each call executes warming sequence. This sequence consists of all\n                existing Kotlin static `object`-s implementing interface `LambdaWarming`.\"\"\"\n        }\n\n        p {\n            +\"Here is a simple snippet of HTTP connection warming:\"\n        }\n\n        kotlin(\n            \"\"\"\n                object DbKeepAlive: LambdaWarming {\n                    override fun warmup() {\n                        Database.sendHeartBeat()\n                    }\n                }\"\"\"\n        )\n\n        p {\n            +\"\"\"Note: by default warming will trigger only initialization of Kotless\n                application, if it was not already initialized.\"\"\"\n        }\n\n        h3 {\n            +\"Initialization\"\n        }\n\n        p {\n            +\"On first call (or during first warm-up) Kotless will perform initialization.\"\n        }\n\n        p {\n            +\"\"\"During initialization Kotless application scans code for Kotless resources\n                (like `LambdaWarming`, `ConversionService` and routes) and registers them.\"\"\"\n        }\n\n        p {\n            +\"\"\"After this Kotless will call `init` on existing Kotlin static `object`-s\n                implementing interface `LambdaInit`. Call is guaranteed to happen only once.\"\"\"\n        }\n\n        p {\n            +\"You may use `LambdaInit` to prepare application before first execution.\"\n        }\n    }\n\n\n    fun permissions() = doc {\n        h1 {\n            +\"Permissions API\"\n        }\n\n        p {\n            +\"\"\"Kotless DSL provides annotations to bind access to objects in your code\n                with permissions granting on the side of cloud provider.\"\"\"\n        }\n\n        h3 {\n            +\"Resource annotations\"\n        }\n\n        p {\n            +\"\"\"Resource annotations are, basically, annotations for classes, Kotlin static\n                `object`-s, functions and properties, which states that access to this particular\n                element in Kotlin requires permissions to stated in annotation cloud provider resource.\"\"\"\n        }\n\n        p {\n            +\"\"\"Here is the simple code snippet, defining Kotlin static `object`, which access DynamoDB\n                table with resource annotations permitting such access on AWS side:\"\"\"\n        }\n\n        kotlin(\n            \"\"\"\n                //Storage have read and write access, so we grant both\n                @DynamoDBTable(\"example-table\", PermissionLevel.ReadWrite)\n                object Storage {\n                    private val table = DynamoTable(\"example-table\")\n\n                    fun add(id: String, value: String) {\n                        table.add(id = id, value = mapOf(\"value\" to value))\n                    }\n\n                    fun get(id: String): String {\n                        return table.get(id = id)[\"value\"]\n                    }\n                    fun add(id: String, value: String) {\n                        table.add(id = id, value = mapOf(\"value\" to value))\n                    }\n\n                    fun get(id: String): String {\n                        return table.get(id = id)[\"value\"]\n                    }\n                }\"\"\"\n        )\n\n        p {\n            +\"Each usage of `Storage` object will grant permission to code in which it was used.\"\n        }\n\n        p {\n            +\"\"\"It means, that if you use `Storage` object in HTTP route, than lambda serving this route\n                will have all permissions defined by annotation.\"\"\"\n        }\n\n        p {\n            +\"Using resource annotations wisely in your code you will not need to worry about permissions at all.\"\n        }\n\n        h3 {\n            +\"Permission level\"\n        }\n\n        p {\n            +\"\"\"Permissions are granted to one of 3 groups of operations: Read, Write and ReadWrite.\n                From the name of each group is pretty clear what operations are covered with it.\"\"\"\n        }\n\n        p {\n            +\"\"\"Note, that all modification/configuration operations are also covered by Write permission.\n                Batch operations included in the same group with single call operations.\n                \"\"\"\n        }\n\n        p {\n            +\"\"\"Permissions were grouped due to two reasons. First of all, we wanted to abstract\n                permissions from specific cloud provider. Secondly, permissions in AWS (and in other\n                cloud providers) are very complex - we wanted to hide this complexity from the end\n                user, so we sacrificed granularity to simplicity.\n                \"\"\"\n        }\n    }\n\n\n    fun http() = doc {\n        h1 {\n            +\"HTTP API\"\n        }\n\n        p {\n            +\"\"\"Kotless DSL provides simple, but yet powerful DSL to create HTTP-based\n                applications. It includes annotations to create HTTP routes, deploy\n                static files, extensible serialization, HTTP request interceptors\n                and rich links API.\"\"\"\n\n        }\n\n        p {\n            +\"We will take a look at these features one by one.\"\n        }\n\n        h2 {\n            +\"Dynamic\"\n        }\n\n        p {\n            +\"\"\"Dynamic HTTP API of Kotless includes everything related to dynamic\n                processing of HTTP requests. Basically it is everything excluding\n                static files located right at S3.\"\"\"\n        }\n\n        h3 {\n            +\"Routes\"\n        }\n\n        p {\n            +\"\"\"Kotless supports `Get` and `Post` function annotations. Each function\n                annotated with them will create new HTTP route with appropriate method.\"\"\"\n        }\n\n        p {\n            +\"\"\"Functions may have parameters. Deserialization of parameters, in case of\n                    primitive types, will be done automatically. Also, you can \"\"\"\n            a(href = \"#Serialization\") {\n                +\"extend deserialization \"\n            }\n            +\"to support non-primitive types as function parameters.\"\n        }\n\n        p {\n            +\"\"\"Serialization of the result also will be done automatically. Nevertheless, it is\n                possible to return data as `HttpResponse` -- in this case no serialization will\n                be performed.\"\"\"\n        }\n\n        p {\n            +\"Here is the simple snippet of dynamic `Get` route:\"\n        }\n\n        kotlin(\n            \"\"\"\n                @Get(\"/\")\n                fun root(): String {\n                    return \"Hello world!\"\n                }\n                \"\"\"\n        )\n\n        h3 {\n            +\"Context\"\n        }\n\n        p {\n            +\"\"\"During processing of HTTP request `KotlessContext.HTTP` object is available\n                for user.\"\"\"\n        }\n\n        p {\n            +\"Context includes current HTTP request at field `request`.\"\n        }\n\n        p {\n            +\"\"\"Note, that call to `request` may throw `KotlinNullPointerException` if this\n                call is performed not in context of HTTP request processing (basically, not\n                in an HTTP route)\"\"\"\n        }\n\n\n        h3 {\n            +\"Interceptor\"\n        }\n\n        p {\n            +\"\"\"Kotless will pass all HTTP requests through interceptors. Each interceptor\n                is a Kotlin static `object` implementing interface `HttpRequestInterceptor`.\"\"\"\n        }\n\n        p {\n            +\"\"\"In case there is more than one interceptor, Kotless will pass request to\n                first of them (ascending order of priority) and will pass as `next` continuation\n                pipeline of next interceptors.\"\"\"\n        }\n\n        p {\n            +\"\"\"Here is the simple snippet of request interceptor, which is checking that\n                header auth token is valid:\"\"\"\n        }\n\n        kotlin(\n            \"\"\"\n                object AuthInterceptor: HttpRequestInterceptor {\n                    override val priority = 0\n\n                    override fun intercept(request: HttpRequest, key: RouteKey,\n                                           next: (HttpRequest, RouteKey) -> HttpResponse): HttpResponse {\n                        if (AuthTokens.isValid(request.headers[\"auth\"])) {\n                            //Pass request to next interceptor or handler, if authentication is valid\n                            return next(request, key)\n                        }\n                        //Redirect to login if authentication is not valid\n                        return redirect(\"/login\")\n                    }\n                }\"\"\"\n        )\n\n        h3 {\n            id = \"Serialization\"\n            +\"Serialization\"\n        }\n\n        p {\n            +\"\"\"Kotless uses `ConversionService` implementations to deserialize parameters of\n                request and serialize them in links. `DefaultConversionService` supports\n                serialization and deserialization of primitive Kotlin types.\"\"\"\n        }\n\n        p {\n            +\"\"\"In case you need to support custom types deserialization, you will need to\n                create Kotlin static `object` implementing interface `ConversionService`.\"\"\"\n        }\n\n        p {\n            +\"Here is the simple snippet, which deserialize entities by ID from a database:\"\n        }\n\n        kotlin(\n            \"\"\"\n                object EntityConversionService: ConversionService {\n                    override fun convertFrom(value: String, type: Type): Any {\n                        if (type !is Class<*>) throw ConversionException(\"Type is not supported\")\n                        if (Entity::class.java.isAssignableFrom(type)) {\n                            return Database.load(value.toLong())\n                        }\n                        throw ConversionException(\"Type is not supported\")\n                    }\n\n                    override fun convertTo(value: Any): String {\n                        if (value is Entity) {\n                            return value.id\n                        }\n                        throw ConversionException(\"Type is not supported\")\n                    }\noverride fun convertTo(value: Any): String {\n                        if (value is Entity) {\n                            return value.id\n                        }\n                        throw ConversionException(\"Type is not supported\")\n                    }\n                }\"\"\"\n        )\n\n        h3 {\n            +\"Links\"\n        }\n\n        p {\n            +\"Kotless provides extension functions to create links (href-s) to Kotless-based routes.\"\n        }\n\n        p {\n            +\"\"\"Basically, there are two types of such links - base links, without any parameters and\n                prepared links with parameters already embedded in a link itself.\n                    \"\"\"\n        }\n\n        p {\n            +\"\"\"Here is the simple snippet creating base and prepared link (pretend that exists annotated\n                function `root(str: String)` in object `API`)\"\"\"\n        }\n\n        p {\n            +\"\"\"Here is the simple snippet creating base and prepared link (pretend that exists annotated\n                function `root(str: String)` in object `API`)\"\"\"\n        }\n\n        kotlin(\n            \"\"\"\n                val baseLink = API::root.href\n                val preparedLink = API::root.href(\"parameter\")\"\"\"\n        )\n\n        h2 {\n            +\"Static\"\n        }\n\n        p {\n            +\"\"\"Static HTTP API of Kotless is a convenient way of creating HTTP routes\n                which are served via static files.\"\"\"\n        }\n\n        p {\n            +\"To create static route you need to use `@StaticGet` annotation.\"\n        }\n\n        p {\n            +\"Note, that this annotation has severe limitations on an annotated object.\"\n        }\n\n        p {\n            +\"\"\"Under annotation should be a property, which value is instantiated directly\n                with `java.io.File(String)` constructor and path should be relative to\n                `workingDir` of Kotless.\"\"\"\n        }\n\n        p {\n            +\"Here is the simple snippet of static route creation:\"\n        }\n\n        kotlin(\n            \"\"\"\n                @StaticGet(\"/file.css\", MimeType.CSS)\n                val exampleCss = File(\"example.css\")\"\"\"\n        )\n\n        p {\n            +\"Links API also works for static routes, but only base link can be constructed:\"\n        }\n\n        kotlin(\"val baseLink = ::exampleCss.href\")\n    }\n\n\n    fun events() = doc {\n        h1 {\n            +\"Events API\"\n        }\n\n        p {\n            +\"\"\"Kotless DSL provides number of annotations to work with different\n                Events sources in the cloud.\"\"\"\n        }\n\n        h2 {\n            +\"Scheduled events\"\n        }\n\n        p {\n            +\"\"\"`Scheduled` annotation declares that function, annotated with it,\n                 should be triggered by a timer.\"\"\"\n        }\n\n        p {\n            +\"Mostly, it should be used to setup scheduled jobs.\"\n        }\n\n        p {\n            +\"\"\"Note, that function should not have any parameters, since it will\n                be called via crontab-like service that passes no context.\"\"\"\n        }\n\n        p {\n            +\"\"\"Annotation requires `cron` argument - it is a cron expression\n                that defines trigger behavior. Its syntax is taken from \"\"\"\n            a {\n                href = \"https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions\"\n                +\"AWS Scheduled Events\"\n            }\n        }\n\n        p {\n            +\"\"\"Also, you can provide `id` argument -- it will be used to create\n                trigger on a cloud side. If case no `id` is provided it will be\n                generated by Kotless during deployment.\n            \"\"\"\n        }\n\n        p {\n            +\"Here is an example of Scheduled job:\"\n        }\n\n        kotlin(\n            \"\"\"\n            @Scheduled(Scheduled.everyHour)\n            fun storageCleanup() {\n                logger.info(\"Starting storage cleanup\")\n                Storage.cleanup()\n                logger.info(\"Ended storage cleanup\")\n            }  \n        \"\"\".trimIndent()\n        )\n    }\n}\n\n\n"
  },
}

export function getBenchmarkFile(language, size) {
  const file = new File("benchmark", "benchmark", `${size}.${language.extension}`)
  file.rawCode = rawCodes[language.technical][size]
  file.status = "raw"
  file.loc = file.computeLoc()

  return file
}